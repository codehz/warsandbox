export let memory;export async function fetchModule(t,e){const n=await fetch(t),i=await WebAssembly.instantiateStreaming(n,{asset:e,console:{console_debug(o,s){console.debug(readStringWithLength(o,s))},console_info(o,s){console.info(readStringWithLength(o,s))},console_log(o,s){console.log(readStringWithLength(o,s))},console_warn(o,s){console.warn(readStringWithLength(o,s))},console_error(o,s){console.error(readStringWithLength(o,s))}}}),c=i.instance.exports;return memory=c.memory,c}const u=new TextDecoder();export function readString(t){const e=new Uint8Array(memory.buffer,t),n=e.findIndex(i=>i==0);return u.decode(e.subarray(0,n))}export function readStringWithLength(t,e){const n=new Uint8Array(memory.buffer,t,e);return u.decode(n)}export function readUint32(t){const e=new Uint32Array(memory.buffer,t,1);return e[0]}export function writeUint32(t,e){const n=new Uint32Array(memory.buffer,t,1);n[0]=e}export function writeFloat(t,e){const n=new Float32Array(memory.buffer,t,1);n[0]=e}export function getUint8BufferFromSlice(t,e){return new Uint8Array(memory.buffer,t,e)}export function getFloat32BufferFromSlice(t,e){return new Float32Array(memory.buffer,t,e/4)}export function getUint32BufferFromSlice(t,e){return new Uint32Array(memory.buffer,t,e/4)}export function getDataViewFromSlice(t,e){return new DataView(memory.buffer,t,e)}export class KeyboardMapper{constructor(t){this._up=!1,this._down=!1,this._left=!1,this._right=!1,this.control=t}update(){let t=0,e=0;this._left&&(t-=1),this._right&&(t+=1),this._up&&(e+=1),this._down&&(e-=1);const n=(t**2+e**2)**.5;n==0?this.control.move=[0,0]:(t/=n,e/=n,this.control.move=[t,e])}set up(t){this._up=t,this.update()}set down(t){this._down=t,this.update()}set left(t){this._left=t,this.update()}set right(t){this._right=t,this.update()}}class r{constructor(t){this.addr=t}get view(){return getDataViewFromSlice(this.addr,22)}set move([t,e]){const n=this.view;n.setFloat32(r.MOVE_X,t,!0),n.setFloat32(r.MOVE_Y,e,!0)}set rotate([t,e]){const n=this.view;n.setFloat32(r.ROTATE_X,n.getFloat32(r.ROTATE_X,!0)+t,!0),n.setFloat32(r.ROTATE_Y,n.getFloat32(r.ROTATE_Y,!0)+e,!0)}set jump(t){this.view.setUint8(r.JUMP,t?1:0)}set sneak(t){this.view.setUint8(r.SNEAK,t?1:0)}set boost(t){this.view.setUint8(r.BOOST,t?1:0)}set use1(t){this.view.setUint8(r.USE1,t?1:0)}set use2(t){this.view.setUint8(r.USE2,t?1:0)}set use3(t){this.view.setUint8(r.USE3,t?1:0)}}r.MOVE_X=0,r.MOVE_Y=4,r.ROTATE_X=8,r.ROTATE_Y=12,r.JUMP=16,r.SNEAK=17,r.BOOST=18,r.USE1=19,r.USE2=20,r.USE3=21;export function getControlMapper(t){return new r(t)}export function readCameraInfo(t){const e=getFloat32BufferFromSlice(t,8*4);return{pos:[e[0],e[1],e[2]],rot:[e[3],e[4]],highlight:[e[5],e[6],e[7]]}}export function readStdLayoutStruct(t,...e){let n={};const i=getUint32BufferFromSlice(t,4*e.length);for(const c in e){const o=e[c];n[o]=i[c]}return n}export function readMapInfo(t){const e=readStdLayoutStruct(t,"chunkWidth","chunkHeight","width","length"),n=8,i=e.chunkWidth*e.chunkWidth*e.chunkHeight*192*4,c=n+i,o=e.chunkWidth*e.chunkWidth*e.chunkHeight*6*6*4,s=c+c;return Object.assign({},e,{dataOffset:n,dataSize:i,indicesOffset:c,indicesSize:o,size:s})}export class ProxiedArray{constructor(t,e,n,i){this.addr=t,this.countAddr=e,this.base=n,this.builder=i}get data(){const t=readUint32(this.countAddr);return this.builder(this.addr,t*this.base)}proxy(t){const e=this;return Object.defineProperty(t,"array",{get(){return e.data}}),t}}export function readMap(t,e){return{data:new ProxiedArray(e+t.dataOffset,e,4,getFloat32BufferFromSlice),indices:new ProxiedArray(e+t.indicesOffset,e+4,4,getUint32BufferFromSlice)}}
